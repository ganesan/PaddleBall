--[[
//  This file was created by LevelHelper
//  http://levelhelper.wordpress.com
//
//  SpriteHelperLoader.lua - online version
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////////////////////////
//  Version history
//  v1.0 First draft for SpriteHelper 1.7
//  v1.1 Added subfolders support
//  v1.2 added removeSelf() - call when you want to release the memory
////////////////////////////////////////////////////////////////////////////////////////////////////
--]]

--[[ HELP - READ THIS TO GET STARTED

Prerequisite
	Add your scene file (SpriteHelper scene file) inside your project directory
	Add the image files generated by SpriteHelper 
	
	HOW TO USE
----------------------------------------------------------------------------------------------------	
require "SpriteHelperLoader"

--SpriteHelperLoader:useHD(true) -- if you want to use the HD image
sLoader = SpriteHelperLoader:initWithContentOfFile("Chopper.pshs")

--creates the sprite with unique name "chopper30001" at position 50, 150
--returns a displayObject
local sprite = sLoader:spriteWithUniqueName("chopper30001", {x = 50, y = 150, xRef = 2, yRef = 3});
local spriteInGroup = sLoader:spriteInGroupWithUniqueName("chopper30001", {x = 120, y = 150}, localGroup)

--creates the sprite with unique name "chopper30001" at position 190, 150 but with box2d body attached to it
--returns a display object with physics
local spriteWithPhysic = sLoader:bodyWithUniqueName("chopper30001", physics, {x = 190, y = 150})
local spriteWithPhysicInGroup = sLoader:bodyInGroupWithUniqueName("chopper30001", physics, {x = 260, y = 150}, localGroup)

--created an animated sprite with the animation that has the unique name "MyChopperAnim" at position 310 150 
--and place it in the group "localGroup" 
--returns a display object
local anim = sLoader:spriteAnimationInGroupWithUniqueName("MyChopperAnim", {x = 310, y = 150}, localGroup)

--created an animated sprite with a box2d body attached with the animation that has the unique name "MyChopperAnim" at position 310 150 
--and place it in the group "localGroup" 
--returns a display object with physics
local animBody = sLoader:bodyAnimationInGroupWithUniqueName("MyChopperAnim", physics, {x = 360, y = 150}, localGroup)

--if animation has "Start At Launch" deselected - you can start an animation by calling play()
--animBody:play()	
	
----------------------------------------------------------------------------------------------------
 --]]

ShUseHD = false
SH_temp_Subfolder = ""
SpriteHelperLoader = {} 
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
function SpriteHelperLoader:initWithContentOfFile(sceneFile)
	if sceneFile == "" then
		print("Invalid scene file given!")
	end
	local object = {SHSprites = {}, SHAnims = {}, subfolder = "", SHUsedSheets = {}}
	setmetatable(object, { __index = SpriteHelperLoader })  -- Inheritance
	object:loadSpriteHelperSceneFile("", sceneFile, system.ResourceDirectory)
	return object
end
----------------------------------------------------------------------------------------------------
function SpriteHelperLoader:initWithContentOfFileFromSubfolder(sceneAndImgSubfolder, sceneFile)
	if sceneFile == "" then
		print("Invalid scene file given!")
	end
	local object = {SHSprites = {}, SHAnims = {}, subfolder = sceneAndImgSubfolder, SHUsedSheets = {}}
	setmetatable(object, { __index = SpriteHelperLoader })  -- Inheritance
	object:loadSpriteHelperSceneFile(sceneAndImgSubfolder, sceneFile, system.ResourceDirectory)
	return object
end
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
function SpriteHelperLoader:initWithContentOfFileFromResourceDir(levelFile, resourceDirectory)
	if sceneFile == "" then
		print("Invalid scene file given!")
	end
	local object = {SHSprites = {}, SHAnims = {}, subfolder = "", SHUsedSheets = {}}
	SH_IMG_subfolder = "";
	setmetatable(object, { __index = SpriteHelperLoader })  -- Inheritance
	object:loadSpriteHelperSceneFile("", sceneFile, resourceDirectory)
	return object
end
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
function SpriteHelperLoader:removeSelf()

self.SHSprites = nil
self.SHAnims = nil
self.subfolder = nil
		
	for i = 1, #self.SHUsedSheets do	
		self.SHUsedSheets[i]:dispose()
		self.SHUsedSheets[i] = nil
	end
	self.SHUsedSheets = nil;
	self.SHUsedSheets = {};
	
	self = nil;


end
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
function SpriteHelperLoader:useHD(value)
	ShUseHD = value
end
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
function SpriteHelperLoader:spriteInGroupWithUniqueName(uniqueName, position, group)
	for i = 1, #self.SHSprites do		
		local spr = self.SHSprites[i]
		if nil ~= string.find(uniqueName, spr["Name"]) then
			return createSpriteInstance(self.subfolder, spr, self.SHUsedSheets, position, group)
		end
	end
	return nil;
end
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
function SpriteHelperLoader:spriteWithUniqueName(uniqueName, position)
	return self:spriteInGroupWithUniqueName(uniqueName, position, nil)	
end
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
function SpriteHelperLoader:bodyInGroupWithUniqueName(uniqueName, physics, position, group)
	for i = 1, #self.SHSprites do		
		local spr = self.SHSprites[i]
		if uniqueName == spr["Name"] then
			local sprite = createSpriteInstance(self.subfolder, spr, self.SHUsedSheets, position, group)
			return createObjectInstance(spr, physics, sprite)
		end
	end
	return nil;	
end
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
function SpriteHelperLoader:bodyWithUniqueName(uniqueName, physics, position)
	return self:bodyInGroupWithUniqueName(uniqueName, physics, position, nil);
end
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
local firstFrame = "" --used as helper for bodyAnimation
function SpriteHelperLoader:spriteAnimationInGroupWithUniqueName(animName, position, group)

	for i = 1, #self.SHAnims do
		local anim = self.SHAnims[i]
		if animName == anim["UniqueName"] then
			
			local frames = anim["Frames"]
			
			local startAtLaunch = anim["StartAtLaunch"]
			local loop = anim["Loop"]
			local repetitions = anim["Repetitions"]
			local speed = anim["Speed"]

			local tableOfSHSprites = {}
			
			for f = 1, #frames do
				firstFrame = frames[1]
				for j = 1, #self.SHSprites do
					local spr = self.SHSprites[j]
					if frames[f] == spr["Name"] then
						table.insert(tableOfSHSprites, spr)
						break
					end
				end
			end
			
			if #tableOfSHSprites > 1 then
				return createAnimSpriteInstance(self.subfolder,tableOfSHSprites, self.SHUsedSheets, position, group,
												speed*10000, loop, repetitions, startAtLaunch)
			end
		end
	end
	
	return nil
end
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
function SpriteHelperLoader:bodyAnimationInGroupWithUniqueName(animName, physics, position, group)
	local sprite = self:spriteAnimationInGroupWithUniqueName(animName, position, group);
	for i = 1, #self.SHSprites do		
		local spr = self.SHSprites[i]
		if firstFrame == spr["Name"] then
			return createObjectInstance(spr, physics, sprite)
		end
	end
	return nil;	
end
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
function SpriteHelperLoader:sheetForAnimationWithUniqueName(animName)

	for i = 1, #self.SHAnims do
		local anim = self.SHAnims[i]
		
		if animName == anim["UniqueName"] then
			local frames = anim["Frames"]
			local startAtLaunch = anim["StartAtLaunch"]
			local loop = anim["Loop"]
			local repetitions = anim["Repetitions"]
			local speed = anim["Speed"]
			local tableOfSHSprites = {}
			
			for f = 1, #frames do
				firstFrame = frames[1]
				for j = 1, #self.SHSprites do
					local spr = self.SHSprites[j]
					if frames[f] == spr["Name"] then
						table.insert(tableOfSHSprites, spr)
						break
					end
				end
			end
			
			if #tableOfSHSprites >= 1 then
				return createAnimSheet(self.subfolder, self.SHUsedSheets, tableOfSHSprites, animName, 
									  loop, repetitions, speed, startAtLaunch)
			end
		end
	end
	
	return nil
end
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
function SpriteHelperLoader:animatedSpriteWithSheets(position, ...)
	return animatedSpriteWithSheetsHelper(position, nil, arg)
end
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
function SpriteHelperLoader:animatedSpriteInGroupWithSheets(position, group, ...)
    return animatedSpriteWithSheetsHelper(position, group, arg)
end
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
function SpriteHelperLoader:bodyWithUniqueNameUsingSheets(uniqueName, physics, position, ...)
	
	for i = 1, #self.SHSprites do		
		local spr = self.SHSprites[i]
		if uniqueName == spr["Name"] then
			local sprite = animatedSpriteWithSheetsHelper(position, nil, arg)
			return createObjectInstance(spr, physics, sprite)
		end
	end
	return nil;	
end
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
function SpriteHelperLoader:bodyInGroupWithUniqueNameUsingSheets(uniqueName, physics, position, 
																group, ...)
	
	for i = 1, #self.SHSprites do		
		local spr = self.SHSprites[i]
		if uniqueName == spr["Name"] then
			local sprite = animatedSpriteWithSheetsHelper(position, group, arg)
			return createObjectInstance(spr, physics, sprite)
		end
	end
	return nil;	
end
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
function animatedSpriteWithSheetsHelper(position, group, arg)
    
    local setInfo = {}
  	for i,v in ipairs(arg) do
		setInfo[#setInfo+1] = { sheet = v.sheet, frames = v.frames}
	end
      
  	--local sprite = require("sprite")
      
    local spriteSet = sprite.newSpriteMultiSet(setInfo)
    
	local oldFrames = 1
	
	local firstAnim = "";
	local startAtLaunch = true
	local firstFrame = true;
  	for i,v in ipairs(arg) do
  		
  		repet = v.repetitions
  		if true == v.loop then
  			repet = 0;
  		end
  		
  		local frm = v.frames
  		local numberOfFrames = #frm

		if true == firstFrame then
			firstAnim = v.uniqueName;
			startAtLaunch = v.startAtLaunch;
			firstFrame = false
		end
		print(v.uniqueName)
		sprite.add(spriteSet, v.uniqueName, oldFrames, numberOfFrames, v.duration*10000, repet)
		oldFrames = oldFrames + #frm	
	end


	local spriteInstance = sprite.newSprite( spriteSet )
	spriteInstance:setReferencePoint(display.CenterReferencePoint)
	
	spriteInstance.x = position.x
	spriteInstance.y = position.y

	if group ~= nil then
		group:insert(spriteInstance)
	end
	
	if ShUseHD then
		spriteInstance.x = position.x * 2.0
		spriteInstance.y = position.y * 2.0
	end

	
	if true == startAtLaunch then
		spriteInstance:prepare(firstAnim)
		spriteInstance:play()
	end
	
	return spriteInstance

end
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
-----------------------PRIVATE METHODS - THIS SHOULD NOT BE USED BY THE USER------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
local helperX = 0
local helperY = 0
local helperWidth = 0
local helperHeight= 0
----------------------------------------------------------------------------------------------------
function rectHelper(a, b, c, d)
	helperX = tonumber(a)
	helperY = tonumber(b)
	helperWidth = tonumber(c)
	helperHeight= tonumber(d)
end
----------------------------------------------------------------------------------------------------
function sizeHelper(a, b)
	helperWidth = tonumber(a)
	helperHeight= tonumber(b)
end
----------------------------------------------------------------------------------------------------
function rectFromString(str)
	string.gsub(str, "{{(.*), (.*)}, {(.*), (.*)}}", rectHelper)	
	uvRect = { origin = {x = helperX, y = helperY}, 
			   	size = {width = helperWidth, height = helperHeight}}
	if ShUseHD then
	uvRect = { origin = {x = helperX*2.0, y = helperY*2.0}, 
				size = {width = helperWidth*2.0, height = helperHeight*2.0}}
	end
	return uvRect
end
----------------------------------------------------------------------------------------------------
function sizeFromStringForSize(str)
	string.gsub(str, "{{(.*), (.*)}, {(.*), (.*)}}", rectHelper)
	size = { width = helperWidth, height = helperHeight}	
	if ShUseHD then
	size = { width = helperWidth*2.0, height = helperHeight*2.0}	
	end
	return size				
end
----------------------------------------------------------------------------------------------------
function sizeFromString(str)
	string.gsub(str, "{(.*), (.*)}", sizeHelper) 
	size = { width = helperWidth, height = helperHeight}
	
	--if ShUseHD then
	--size = { width = helperWidth*2.0, height = helperHeight*2.0}	
	--end
	return size				
end
----------------------------------------------------------------------------------------------------
function pointFromString(str)
	--print(str)
	string.gsub(str, "{(.*), (.*)}", sizeHelper) 
	point = { x = helperWidth, y = helperHeight}
	if ShUseHD then
		point = { x = helperWidth*2.0, y = helperHeight*2.0}
	end
	return point
end
----------------------------------------------------------------------------------------------------
local SHimg = ""
local SHext = ""
function helpImgRetina(a, b)
	SHimg = a
	SHext = b
end
----------------------------------------------------------------------------------------------------
function correctImageFile(subfolder, str)
	local correctStr = str;
	if ShUseHD then
		corrector = "" .. "-hd" .. ".";
		correctStr = string.gsub(str, "(%a+).(%a+)", helpImgRetina)
		correctStr = SHimg .. corrector  .. SHext
	end
	--print(correctStr)
	return subfolder .. correctStr;
end
----------------------------------------------------------------------------------------------------
function createAnimSpriteInstance(subfolder, tableOfSHSprites, saveSheet, position, group, 
									speed, loop, repetitions, startAtLaunch)
	local tableForSheet = {}
	for i = 1, #tableOfSHSprites do
		local sprite = tableOfSHSprites[i];
		table.insert(tableForSheet, {name = sprite["Name"], 
								 uvRect = rectFromString(sprite["Frame"]),
								 size = sizeFromStringForSize(sprite["Frame"])})
	end
	return setPropertiesAndReturnSprite(subfolder,
									tableOfSHSprites[1],
									saveSheet,
									position,
									group,

									animSheetForSprites(tableForSheet),
									#tableOfSHSprites, 
									speed, loop, repetitions, startAtLaunch)
end
----------------------------------------------------------------------------------------------------
function createAnimSheet(subfolder, sheetHolder, tableOfSHSprites, animName,
						loop, repetitions, speed, startAtLaunch)
	local tableForSheet = {}
	for i = 1, #tableOfSHSprites do
		local sprite = tableOfSHSprites[i];
		table.insert(tableForSheet, {name = sprite["Name"], 
								 uvRect = rectFromString(sprite["Frame"]),
								 size = sizeFromStringForSize(sprite["Frame"])})
	end
	
	return setPropertiesAndReturnAnimSheet(subfolder,sheetHolder, tableOfSHSprites[1], 
									  animSheetForSprites(tableForSheet),
									  #tableOfSHSprites, animName,
									  loop, repetitions, speed, startAtLaunch)
end

----------------------------------------------------------------------------------------------------
function createSpriteInstance(subfoder, shSprite, saveSheet, position, group) -- sprite is a SpriteHelperSprite
		
	return setPropertiesAndReturnSprite(subfoder,
										shSprite, 
										saveSheet,
										position, 
										group,
										
										sheetForSprite( shSprite["Name"], 
									  					rectFromString(shSprite["Frame"]),
														sizeFromStringForSize(shSprite["Frame"])
														),
										1,
										1000,
										false, 1, true)
end
----------------------------------------------------------------------------------------------------
function setPropertiesAndReturnSprite(subfolder, shSprite,saveSheet, position, group, sheetData, frames, 
										speed, loop, repetitions, startAtLaunch)

	local sprite = require("sprite")

	spriteSheet = sprite.newSpriteSheetFromData(	correctImageFile(subfolder, shSprite["Image"]), 
														system.ResourceDirectory,
														sheetData )
	
	saveSheet[#saveSheet+1] = spriteSheet;
								
	local spriteSet = sprite.newSpriteSet(spriteSheet, 1, frames)
		
	if true == loop then
		repetitions = 0
	end
	
	sprite.add(	spriteSet, 
				shSprite["Name"], 
				1, frames, speed, repetitions)
	local spriteInstance = sprite.newSprite( spriteSet )
	spriteInstance:setReferencePoint(display.CenterReferencePoint)
	if group ~= nil then
		group:insert(spriteInstance)
	end
	
	if(position.xRef)then
		spriteInstance.xReference = position.xRef;
	end
	
	if(position.yRef)then
		spriteInstance.yReference = position.yRef;
	end
	
	
	spriteInstance.x = position.x
	spriteInstance.y = position.y
	
	if ShUseHD then
		spriteInstance.x = position.x * 2.0
		spriteInstance.y = position.y * 2.0
	end
	
	--this part is for physic objects
	local scale = sizeFromString(shSprite["Scale"])
	spriteInstance.width = spriteInstance.width * scale.width
	spriteInstance.height = spriteInstance.height * scale.height
	--this part is for display of the objects
	
	spriteInstance.xScale = scale.width
	spriteInstance.yScale = scale.height

	spriteInstance.alpha = shSprite["Opacity"]
	spriteInstance:prepare( shSprite["Name"] )
	
	if true == startAtLaunch then
		spriteInstance:play()
	end
		
	return spriteInstance

end
----------------------------------------------------------------------------------------------------
function setPropertiesAndReturnAnimSheet(subfolder, 
										sheetHolder,
										shSprite, 
									  	sheetData,
									  	frames, animName,
									  	_loop, _repetitions, _speed, _startAtLaunch)

	local sprite = require("sprite")

	local spriteSheet = sprite.newSpriteSheetFromData(	correctImageFile(subfolder, shSprite["Image"]), 
														system.ResourceDirectory,
														sheetData )
														
	sheetHolder[#sheetHolder+1] = spriteSheet;

	local frm = {}
	
	for i = 1, frames do
		frm[#frm+1] = i;
	end
	
	return { sheet = spriteSheet, frames = frm,
			uniqueName = animName, 
			loop = _loop, 
			repetitions = _repetitions, 
			duration = _speed, 
			startAtLaunch = _startAtLaunch};
end

----------------------------------------------------------------------------------------------------
function getPolygonPointsFromStrings(fixtures, scale, sdensity, 
									sfriction, srestitution, offsetX, offsetY, scollisionFilter)
-- for CORONA points must be inverse so multiply y by -1 and then inverse the points order
	local finalBodyShape = {}
	local currentFixInfo;
	local currentShapeRevised = {}
	local currentShape = {}
	
	for i = 1, #fixtures do
		local currentFix = fixtures[i]
			
		for j = 1, #currentFix do
			local point = pointFromString(currentFix[j])
			currentShape[#currentShape+1] = point.x + offsetX
			currentShape[#currentShape+1] = point.y - offsetY
		end
		
		currentFix = nil;
		
		for k = #currentShape,1,-2 do
			currentShape[k-1] = currentShape[k-1]*scale.width
			currentShape[k] = currentShape[k]*(-1)*scale.height
		end	

		for l = #currentShape,1,-2 do
			currentShapeRevised[#currentShapeRevised + 1] = currentShape[l-1];
			currentShapeRevised[#currentShapeRevised + 1] = currentShape[l];
		end	
		
		currentFixInfo = { density = sdensity,
						   friction = sfriction,
						   bounce = srestitution,
						   shape = deepcopy(currentShapeRevised),
						   filter = scollisionFilter
								 }
		currentShape = nil
		currentShape = {}
		currentShapeRevised = nil
		currentShapeRevised = {}
		finalBodyShape[#finalBodyShape+1] = currentFixInfo;
	end


	return finalBodyShape
end
----------------------------------------------------------------------------------------------------
function createObjectInstance(shSprite, physics, sprite)

	local fixtures = shSprite["ShapeFixtures"]

	local physicType = "static"
	if shSprite["PhysicType"] == 1 then
		physicType = "kinematic"
	end
	if shSprite["PhysicType"] == 2 then
		physicType = "dynamic"
	end

	local scale = sizeFromString(shSprite["Scale"])
	
	local collisionFilter = { 	categoryBits = shSprite["Category"], 
								maskBits = shSprite["Mask"], 
								groupIndex = shSprite["Group"] } 


	if nil == fixtures then
		-- sprite does not have polygon points
		-- check if its circle if not make it rectangle
		local size = sizeFromStringForSize(shSprite["Frame"])
		
		if false == shSprite["IsCircle"] then
			--for quad bases i will use fixture to simulate in order to be able to 
			--make the border implementation
			physics.addBody(sprite, 
							physicType,
							{ density = shSprite["Density"],
							  friction= shSprite["Friction"],
							  bounce   = shSprite["Restitution"],
							  filter = collisionFilter,
							  shape = deepcopy(getQuad(sprite.contentWidth, 
							  							sprite.contentHeight, 
							  							shSprite["ShapeBorderW"]/2, 
							  							shSprite["ShapeBorderH"]/2,
							  							shSprite["ShapePositionOffsetX"]/2,
				  										shSprite["ShapePositionOffsetY"]/2))})
		else
			-- object is circle
			
			physics.addBody( sprite, 
							physicType,
							{ 	density = shSprite["Density"], 
								friction = shSprite["Friction"], 
								bounce = shSprite["Restitution"], 
								radius = (size.width-shSprite["ShapeBorderW"]/2)/2*scale.width,
								filter = collisionFilter
							} )
		end
	else	
	
		physics.addBody( sprite, 
						 physicType,
						unpack(getPolygonPointsFromStrings(fixtures, 
						 							 scale, 
						 							  shSprite["Density"],
						 							  shSprite["Friction"], 
						 							  shSprite["Restitution"],
							  						  shSprite["ShapePositionOffsetX"]/2,
				  									  shSprite["ShapePositionOffsetY"]/2,
						 							  collisionFilter))
						 	)
	end
	
	sprite:setLinearVelocity(shSprite["LinearVelocityX"], shSprite["LinearVelocityY"])
	sprite.angularDamping = shSprite["AngularDamping"]
	sprite.linearDamping = shSprite["LinearDamping"];
	sprite.angularVelocity = shSprite["AngularVelocity"];
	sprite.isSleepingAllowed = shSprite["CanSleep"];
	sprite.isBullet = shSprite["IsBullet"];
	sprite.isFixedRotation = shSprite["IsFixedRot"]
	sprite.isSensor = shSprite["IsSensor"];
	
	return sprite
end
----------------------------------------------------------------------------------------------------
function getQuad(width, height, borderW, borderH, offsetX, offsetY)

    pos = { x = 0, y = 0 } 
    
    width = (width - borderW)
    height= (height -borderH)

	local quad = { pos.x - width/2 + offsetX, 
			 	   pos.y + height/2 + offsetY,
			 
             	   pos.x - width/2 + offsetX,
             	   pos.y - height/2 + offsetY,
        
	               pos.x + width/2 + offsetX,
      		       pos.y - height/2 + offsetY,
             
            	   pos.x + width/2 + offsetX,
             	   pos.y + height/2 + offsetY}
 
	return quad
 
end
----------------------------------------------------------------------------------------------------
function sheetForSprite(name, uvRect, size)

	local sheet = { 
	
		frames = {  frameForSheet(name, uvRect, size) }
			  }
	
	return sheet
end
----------------------------------------------------------------------------------------------------
function animSheetForSprites(tableOfSHSprites)

	local sheet = { frames = {} }
	for i = 1, #tableOfSHSprites do

		table.insert(sheet.frames, frameForSheet(tableOfSHSprites[i].name,
												 tableOfSHSprites[i].uvRect,
												 tableOfSHSprites[i].size))

	end
	return sheet
end
----------------------------------------------------------------------------------------------------
function frameForSheet(name, uvRect, size)
		
	return	{
				name = name,
				spriteColorRect = { x = uvRect.origin.x, 
									y = uvRect.origin.y, 
									width = uvRect.size.width, 
									height = uvRect.size.height }, 
				textureRect = { x = uvRect.origin.x, 
								y = uvRect.origin.y, 
								width = uvRect.size.width, 
								height = uvRect.size.height }, 
				spriteSourceSize = { width = size.width, 
									 height= size.height}, 
				spriteTrimmed = false,
				textureRotated = false
		}
end
----------------------------------------------------------------------------------------------------
function deepcopy(object)
    local lookup_table = {}
    local function _copy(object)
        if type(object) ~= "table" then
            return object
        elseif lookup_table[object] then
            return lookup_table[object]
        end
        local new_table = {}
        lookup_table[object] = new_table
        for index, value in pairs(object) do
            new_table[_copy(index)] = _copy(value)
        end
        return setmetatable(new_table, getmetatable(object))
    end
    return _copy(object)
end
----------------------------------------------------------------------------------------------------
local currentSpriteInfo = {}
local readSprites = false

local currentAnimInfo = {}
local readAnims = false
local currentAnimFrames = {}
local readFrames = false;

local currentPolygonInfo = {}
local currentFixtureInfo = {}
local readFixture = false

local currentKey;

local dict = 0
local array = 0
----------------------------------------------------------------------------------------------------
function key(arg)
	currentKey = arg
	--print("KEY ")
	--print(arg)
	if nil ~= string.find(arg, "ANIMATION_INFO") then
		readAnims = true
	end
	if nil ~= string.find(arg, "Frames") then
		readFrames = true
	end

	if nil ~= string.find(arg, "SPRITES_INFO") then
		readSprites = true
	end

	if nil ~= string.find(arg, "Fixtures") then
		readFixture = true
	end

end
----------------------------------------------------------------------------------------------------
function stringValue(arg)
	pushValue(arg)
end
function numberValue(arg)
	pushValue(tonumber(arg))
end

function boolValue(arg)
	pushValue(arg)
end
----------------------------------------------------------------------------------------------------
function pushValue(arg)
--	print("CURRENT KEY")
--	print(currentKey)
--	print("VALUE")
--	print(arg)
	if readSprites then
		currentSpriteInfo[currentKey] = arg
	end
		
	if readFixture then
		currentFixtureInfo[#currentFixtureInfo+1] = arg
	end
	
	if readAnims then
		if false == readFrames then
			currentAnimInfo[currentKey] = arg
		end
	end
	
	if readFrames then
		currentAnimFrames[#currentAnimFrames +1] = arg
	end
end
----------------------------------------------------------------------------------------------------
function arrayBegin(arg)
	array = array+1
end
----------------------------------------------------------------------------------------------------
function noArray(arg)
	readFixture = false
end
----------------------------------------------------------------------------------------------------
function arrayEnd(arg)
	array = array-1

	if array == 0 then
--		if readSprites then
--			readSprites = false
--		end

		readAnims = false
		readSprites = false
	end
	
	if readFixture then
		if array == 2 then
			currentPolygonInfo[#currentPolygonInfo+1] = deepcopy(currentFixtureInfo)			
			currentFixtureInfo = nil;
			currentFixtureInfo = {}
		end
	
		if array == 1 then
		print(currentSpriteInfo["Name"])
			currentSpriteInfo["ShapeFixtures"] = deepcopy(currentPolygonInfo)
			readFixture = false
			currentPolygonInfo = nil
			currentPolygonInfo = {}
		end
	end
	
	if readFrames then
		if array == 1 then
			currentAnimInfo["Frames"] = deepcopy(currentAnimFrames)
			readFrames = false;
			currentAnimFrames = nil;
			currentAnimFrames = {}
		end
	end
end
----------------------------------------------------------------------------------------------------
function dictBegin(arg)
	dict = dict+1
--	print("DICT VALUE")
--	print(dict)
end
----------------------------------------------------------------------------------------------------
function  SpriteHelperLoader:dictEnd()
	dict = dict-1
	if dict == 1 then
		if readSprites then
			self.SHSprites[#self.SHSprites+1] = deepcopy(currentSpriteInfo)
			currentSpriteInfo = nil
			currentSpriteInfo = {}
		end		
		
		if readAnims then
			self.SHAnims[#self.SHAnims+1] = deepcopy(currentAnimInfo)
			currentAnimInfo = nil
			currentAnimInfo = {}
			--readAnims = false;
			readFrames= false;
		end
	end
end
----------------------------------------------------------------------------------------------------
function SpriteHelperLoader:loadSpriteHelperSceneFile(subfolder, sceneFile, resourceDirectory)




	local path = system.pathForFile(subfolder .. sceneFile, resourceDirectory)

	local file = io.open(path, "r")
 
 	-- Determine if file exists
	if file then
   		
   		for line in file:lines() do
   		--print(line)
			string.gsub(line, "<key>(.*)</key>", key)
			string.gsub(line, "<string>(.*)</string>", stringValue)
			string.gsub(line, "<real>(.*)</real>", numberValue)
			string.gsub(line, "<integer>(.*)</integer>", numberValue)
	
			if nil ~= string.find(line, "<true/>") then
				boolValue(true)
			end
			if nil ~= string.find(line, "<false/>") then
				boolValue(false)
			end
	
			string.gsub(line, "<dict>", dictBegin)
			
			if nil ~= string.find(line, "</dict>") then
				self:dictEnd()
			end

			string.gsub(line, "<array>", arrayBegin)
			string.gsub(line, "</array>", arrayEnd)
			string.gsub(line, "<array/>", noArray)
		end
    	
   		io.close (file)
	else
    	print( "Scene file not found. Please add your scene in the project directory." )
	end


	currentSprite = 0
	currentSpriteInfo = {}
	readSprites = false

	currentFixture = 0
	currentPolygonInfo = {}
	currentFixtureInfo = {}
	currentFixturePoint = 0
	readFixture = false

	currentKey = "";
	dict = 0
	array = 0

	 --For debuging

--[[
	for i = 1, #self.SHSprites do
	print("-----------------------------------------------------------------------")
	print("SPRITE INFO")
	print("-----------------------------------------------------------------------")
		for k, v in pairs (self.SHSprites[i]) do
			print(k)
			print(v)
		end
	end

	for i = 1, #self.SHAnims do
	print("-----------------------------------------------------------------------")
	print("ANIM INFO")
	print("-----------------------------------------------------------------------")
		for k, v in pairs (self.SHAnims[i]) do
			print(k)
			print(v)
			if nil ~= string.find(k, "Frames") then
				for j = 1, #v do
					print(v[j])
				end
			end	
		end
	end
--]]

end
